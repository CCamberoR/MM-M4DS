[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module generate('https://www.example.org/contract', 'https://www.example.org/workflow')]

[import Acceleo::MM_M4DS_Workflow::main::generate/]


[template public generateContract(aContract : Contract)]

[/template]

[template public generateCallContract(aContract : Contract)]
[if (aContract._in.oclIsTypeOf(DataField))]						[comment OPEN checks that the contract data input is a DataField/]
[let df : DataField = aContract._in.oclAsType(DataField)]		[comment OPEN assigns the variable to be of type DataField/]
[comment]The contracts below are of type FieldRange[/comment]
[if (aContract.oclIsTypeOf(FieldRange))]						[comment OPEN checks that the contract is of type FieldRange (usually a Pre or Post condition)/]
[let fr : FieldRange = aContract.oclAsType(FieldRange)]			[comment OPEN assigns the variable to be of type FieldRange/]
field_list_[aContract.name/]=['['/][for (field : Field | fr.field) separator(', ')]'[field.dataField.displayName/]'[/for][']'/]
if pre_post.checkFieldRange(fields=field_list_[aContract.name/],
							dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/],
							belongOp=Belong([if (fr.belongOp=BelongOp::BELONG)]0[else]1[/if]))
	print('[aContract.type/] call returned TRUE')
else:
	print('[aContract.type/] call returned FALSE')
[/let]															[comment CLOSE assigns the variable to be of type FieldRange/]
[/if]															[comment CLOSE checks that the contract is of type FieldRange (usually a Pre or Post condition)/]
[comment]The contracts below are of type ValueRange[/comment]
[if (aContract.oclIsTypeOf(ValueRange))]						[comment OPEN checks that the contract is of type ValueRange (usually a Pre or Post condition)/]
[let vr : ValueRange = aContract.oclAsType(ValueRange)]			[comment OPEN assigns the variable to be of type ValueRange/]
[for (v : Value | vr.value)]									[comment OPEN traverse all the values in the contract to know which pre-post contract call/]
[if (v.oclIsTypeOf(FixValue))]									[comment OPEN checks that the value to check is a FixValue/]
	[let fv : FixValue = v.oclAsType(FixValue)]					[comment OPEN assigns the variable to be of type FixValue/]
[if (v.quantity <> null)]										[comment OPEN checks that the quantity is not null (there is an operator and a quant)/]
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]					[comment OPEN checks that the quantity is of type Absolute/]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]					[comment OPEN assigns the variable to be of type Absolute/]
if pre_post.checkFixValueRange([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]',
								quant_abs=[av.value/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if])):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]																			[comment CLOSE assigns the variable to be of type Absolute/]
	[elseif (v.quantity.oclIsTypeOf(Percent))]					[comment OPEN checks that the quantity is of type Percent/]
		[let per : Percent = v.quantity.oclAsType(Percent)]		[comment OPEN assigns the variable to be of type Percent/]
if pre_post.checkFixValueRange([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]',
								quant_rel=[per.percent/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if])):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]													[comment CLOSE assigns the variable to be of type Percent/]
	[/if]														[comment CLOSE checks that the quantity is of type Absolute or Percent/]
	[else]														[comment OPEN checks that the quantity not null (there are not operators or quants)/]
if pre_post.checkFixValueRange([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]',
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
[/if]															[comment CLOSE checks that the quantity is not null (there are not operators or quants)/]
	[/let]														[comment CLOSE assigns the variable to be of type FixValue/]
[elseif (v.oclIsTypeOf(Interval))]								[comment OPEN checks that the variable is of type Interval/]
	[let inter : Interval = v.oclAsType(Interval)]				[comment OPEN assigns the variable to be of type Interval/]
if pre_post.checkIntervalRangeFloat(left_margin=[inter.leftMargin/], rigth_margin=[inter.rightMargin/], dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/],
                                	closureType=Closure([if (inter.closureType=ClosureType::openOpen)]0[elseif (inter.closureType=ClosureType::openClosed)]1[elseif (inter.closureType=ClosureType::closedOpen)]2[elseif (inter.closureType=ClosureType::closedClosed)]3[/if]), belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field='[df.dataField.displayName/]')
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[/let]														[comment CLOSE assigns the variable to be of type Interval/]
[elseif (v.oclIsTypeOf(SpecialValue))]							[comment OPEN checks that the variable is of type SpecialValue/]
	[let sv : SpecialValue = v.oclAsType(SpecialValue)]			[comment OPEN assigns the variable to be of type SpecialValue/]
[if (v.quantity <> null)]										[comment OPEN checks that the quantity is not null (there are not operators or quants)/]
[if (sv.specialType=SpecialType::MISSING)]						[comment OPEN checks that the SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][if (vr._in.oclIsTypeOf(DataField))][let df : DataField = vr._in.oclAsType(DataField)][for (mv : ValueField | df.dataField.missingValues) separator(', ')][if (df.dataField.dataType=DataType::String or df.dataField.dataType=DataType::Time or df.dataField.dataType=DataType::DateTime)]'[mv.value/]'[else][mv.value/][/if][/for][/let][']'/][/if]
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]					[comment OPEN checks that the quantity is Absolute/]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]			[comment OPEN assigns the variable to be of type AbsoluteValue/]
if pre_post.checkMissingRange(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								missing_values=missing_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/]):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]																	[comment CLOSE assigns the variable to be of type AbsoluteValue/]
	[elseif (v.quantity.oclIsTypeOf(Percent))]					[comment OPEN checks that the quantity is Percent/]
		[let per : Percent = v.quantity.oclAsType(Percent)]		[comment OPEN assigns the variable to be of type Percent/]
if pre_post.checkMissingRange(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								missing_values=missing_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]													[comment CLOSE assigns the variable to be of type Percent/]
	[/if]														[comment CLOSE checks that the quantity is AbsoluteValue or Percent/]
[elseif (sv.specialType=SpecialType::INVALID)]					[comment OPEN checks that the SpecialType is INVALID/]
invalid_values_[aContract.name/]=['['/][if (vr._in.oclIsTypeOf(DataField))][let df : DataField = vr._in.oclAsType(DataField)][for (mv : ValueField | df.dataField.invalidValues) separator(', ')][mv.value/][/for][/let][']'/][/if]
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]					[comment OPEN checks that the quantity is AbsoluteValue/]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]		[comment OPEN assigns the variable to be of type AbsoluteValue/]
if pre_post.checkInvalidValues(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								invalid_values=invalid_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/]):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]																[comment CLOSE assigns the variable to be of type AbsoluteValue/]
	[elseif (v.quantity.oclIsTypeOf(Percent))]								[comment OPEN checks that the quantity is Percent/]
		[let per : Percent = v.quantity.oclAsType(Percent)]					[comment OPEN assigns the variable to be of type Percent/]
if pre_post.checkInvalidValues(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								invalid_values=invalid_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]																[comment CLOSE assigns the variable to be of type AbsoluteValue/]
	[/if]														[comment CLOSE checks that the quantity is AbsoluteValue or Percent/]
[elseif (sv.specialType=SpecialType::OUTLIER)]					[comment OPEN checks that the SpecialType is OUTLIER/]
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]					[comment OPEN checks that the quantity is AbsoluteValue/]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]			[comment OPEN assigns the variable to be of type AbsoluteValue/]
if pre_post.checkOutliers(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/]):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]																	[comment CLOSE assigns the variable to be of type AbsoluteValue/]
	[elseif (v.quantity.oclIsTypeOf(Percent))]									[comment OPEN checks that the quantity is Percent/]
		[let per : Percent = v.quantity.oclAsType(Percent)]						[comment OPEN assigns the variable to be of type Percent/]
if pre_post.checkOutliers(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]																	[comment CLOSE assigns the variable to be of type Percent/]
	[/if]															[comment CLOSE checks that the quantity is AbsoluteValue or Percent/]
[/if]																[comment CLOSE checks that the SpecialType is MISSING, INVALID or OUTLIER/]
[elseif (v.quantity = null)]										[comment OPEN checks that the quantity is null/]
	[if (sv.specialType=SpecialType::MISSING)]						[comment OPEN checks that the SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][if (vr._in.oclIsTypeOf(DataField))][let df : DataField = vr._in.oclAsType(DataField)][for (mv : ValueField | df.dataField.missingValues) separator(', ')][if (df.dataField.dataType=DataType::String or df.dataField.dataType=DataType::Time or df.dataField.dataType=DataType::DateTime)]'[mv.value/]'[else][mv.value/][/if][/for][/let][']'/][/if]
if pre_post.checkMissingRange(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								missing_values=missing_values_[aContract.name/],
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[elseif (sv.specialType=SpecialType::INVALID)]					[comment OPEN checks that the SpecialType is INVALID/]
invalid_values_[aContract.name/]=['['/][if (vr._in.oclIsTypeOf(DataField))][let df : DataField = vr._in.oclAsType(DataField)][for (mv : ValueField | df.dataField.invalidValues) separator(', ')][mv.value/][/for][/let][']'/][/if]
if pre_post.checkInvalidValues(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								invalid_values=invalid_values_[aContract.name/],
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[elseif (sv.specialType=SpecialType::OUTLIER)]					[comment OPEN checks that the SpecialType is OUTLIER/]
if pre_post.checkOutliers(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[df.dataField.eContainer(Workflow::DataDictionary).name/], field='[df.dataField.displayName/]', 
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[/if]													[comment CLOSE checks that the SpecialType is MISSING, INVALID or OUTLIER/]
[/if]														[comment CLOSE checks that the quantity is not null (there are not operators or quants)/]
	[/let]													[comment CLOSE assigns the variable to be of type SpecialValue/]
[/if]														[comment CLOSE checks that the quantity is null or not null/]
[/for]														[comment CLOSE traverse all the values in the contract to know which pre-post contract call/]
[/let]														[comment CLOSE assigns the variable to be of type ValueRange/]
[elseif (aContract.oclIsTypeOf(Condition))]					[comment OPEN Contracts of type Condition (Invariants)/]
[generateCallConditionContract(aContract)/]
[/if]														[comment CLOSE aContract.oclIsTypeOf()/]
[/let]														[comment CLOSE assigns the variable to be of type DataField/]
[elseif (aContract._in.oclIsTypeOf(DataDictionary))]		[comment OPEN assigns the variable to be of type DataDictionary/]
[generateCallDataDicContract(aContract)/]
[/if]														[comment CLOSE assigns the variable to be of type DataField or DataDictionary/]
[/template]


[template public generateCallDataDicContract(aContract : Contract)] [comment IT IS THE SAME AS generateCallContract(aContract : Contract) but the data input to the contract is a DataDictionary instead of a DataField/]
[let dd : DataDictionary = aContract._in.oclAsType(DataDictionary)]
[comment]The contracts below are of type FieldRange[/comment]
[if (aContract.oclIsTypeOf(FieldRange))]						[comment OPEN checks that the contract is of type FieldRange (usually a Pre or Post condition)/]
[let fr : FieldRange = aContract.oclAsType(FieldRange)]			[comment OPEN assigns the variable to be of type FieldRange/]
field_list_[aContract.name/]=['['/][for (field : Field | fr.field) separator(', ')]'[field.dataField.displayName/]'[/for][']'/]
if pre_post.checkFieldRange(fields=field_list_[aContract.name/],
							dataDictionary=[dd.dataDictionary.name/],
							belongOp=Belong([if (fr.belongOp=BelongOp::BELONG)]0[else]1[/if]))
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
[/let]															[comment CLOSE assigns the variable to be of type FieldRange/]
[/if]															[comment CLOSE checks that the contract is of type FieldRange (usually a Pre or Post condition)/]
[if (aContract.oclIsTypeOf(ValueRange))]
[let vr : ValueRange = aContract.oclAsType(ValueRange)]
[for (v : Value | vr.value)]
[if (v.oclIsTypeOf(FixValue))]
	[let fv : FixValue = v.oclAsType(FixValue)]
[if (v.quantity <> null)]
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]
if pre_post.checkFixValueRange([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], dataDictionary=[dd.dataDictionary.name/], belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_abs=[av.value/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if])):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[elseif (v.quantity.oclIsTypeOf(Percent))]
		[let per : Percent = v.quantity.oclAsType(Percent)]
if pre_post.checkFixValueRange([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], dataDictionary=[dd.dataDictionary.name/], belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_rel=[per.percent/], quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if])):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[/if]
	[else]
if pre_post.checkFixValueRange([if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], dataDictionary=[dd.dataDictionary.name/], belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None,
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
[/if]
	[/let]
[elseif (v.oclIsTypeOf(Interval))]
	[let inter : Interval = v.oclAsType(Interval)]
if pre_post.checkIntervalRangeFloat(left_margin=[inter.leftMargin/], rigth_margin=[inter.rightMargin/], dataDictionary=[dd.dataDictionary.name/],
                               closureType=Closure([if (inter.closureType=ClosureType::openOpen)]0[elseif (inter.closureType=ClosureType::openClosed)]1[elseif (inter.closureType=ClosureType::closedOpen)]2[elseif (inter.closureType=ClosureType::closedClosed)]3[/if]), belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), field=None)
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[/let]
[elseif (v.oclIsTypeOf(SpecialValue))]
	[let sv : SpecialValue = v.oclAsType(SpecialValue)]
[if (v.quantity <> null)]
[if (sv.specialType=SpecialType::MISSING)]
missing_values_[aContract.name/]=None
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]
if pre_post.checkMissingRange(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								missing_values=missing_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/]):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[elseif (v.quantity.oclIsTypeOf(Percent))]
		[let per : Percent = v.quantity.oclAsType(Percent)]
if pre_post.checkMissingRange(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								missing_values=missing_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[/if]
[elseif (sv.specialType=SpecialType::INVALID)]
invalid_values_[aContract.name/]=None
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]
if pre_post.checkInvalidValues(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								invalid_values=invalid_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/]):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[elseif (v.quantity.oclIsTypeOf(Percent))]
		[let per : Percent = v.quantity.oclAsType(Percent)]
if pre_post.checkInvalidValues(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								invalid_values=invalid_values_[aContract.name/],
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[/if]
[elseif (sv.specialType=SpecialType::OUTLIER)]
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]
if pre_post.checkOutliers(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_abs=[av.value/]):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[elseif (v.quantity.oclIsTypeOf(Percent))]
		[let per : Percent = v.quantity.oclAsType(Percent)]
if pre_post.checkOutliers(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								quant_op=Operator([if(v.quantity.operator=Operator::greatherEqual)]0[elseif(v.quantity.operator=Operator::greather)]1[elseif(v.quantity.operator=Operator::lessEqual)]2[elseif(v.quantity.operator=Operator::less)]3[elseif(v.quantity.operator=Operator::equal)]4[/if]), quant_rel=[per.percent/]/100):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
		[/let]
	[/if]
[/if]
[elseif (v.quantity = null)]
	[if (sv.specialType=SpecialType::MISSING)]
missing_values_[aContract.name/]=None
if pre_post.checkMissingRange(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								missing_values=missing_values_[aContract.name/],
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[elseif (sv.specialType=SpecialType::INVALID)]
invalid_values_[aContract.name/]=None
if pre_post.checkInvalidValues(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								invalid_values=invalid_values_[aContract.name/],
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[elseif (sv.specialType=SpecialType::OUTLIER)]
if pre_post.checkOutliers(belongOp=Belong([if (vr.belongOp=BelongOp::BELONG)]0[else]1[/if]), dataDictionary=[dd.dataDictionary.name/], field=None, 
								quant_abs=None, quant_rel=None, quant_op=None):
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
	[/if]
[/if]
	[/let]
[/if]
[/for]
[/let]
[elseif (aContract.oclIsTypeOf(Condition))]					[comment OPEN Contracts of type Condition (Invariants)/]
[generateCallConditionContract(aContract)/]
[/if]
[/let]
[/template]


[template public generateCallConditionContract(aContract : Contract)]
[let cond : Condition = aContract.oclAsType(Condition)]						[comment OPEN assigns the contract to be of type Condition (Invariants)/]
[for (if_cond : If | cond._if)]												[comment OPEN traverse all the If class in the contract/]
[if (cond._in.oclIsTypeOf(DataField))]										[comment OPEN checks that the input is a DataField/]
[let df : DataField = cond._in.oclAsType(DataField)]						[comment OPEN assigns the variable to be of type DataField/]
[let th : Then = if_cond._then.oclAsType(Then)]								[comment OPEN assigns the variable to be of type Then/]
[for (v : Value | if_cond.valueCondition)]									[comment OPEN traverse all the values associated to the contract/]
[if (v.oclIsTypeOf(FixValue))]												[comment OPEN checks that the type of the value is FixValue/]
	[let fv : FixValue = v.oclAsType(FixValue)]								[comment OPEN assigns the variable to be of type FixValue/]
[comment]The code below generates the call to invariants of type FixValue-FixValue[/comment]
	[if (th.valueResult.oclIsTypeOf(FixValue))]								[comment OPEN checks that the variable is of type FixValue/]
		[let fvt : FixValue = th.valueResult.oclAsType(FixValue)]			[comment OPEN assigns the variable to be of type FixValue/]
[if (aContract.out.oclIsTypeOf(DataDictionary))]							[comment OPEN checks that the variable is of type DataDictionary/]
[let dd_out : DataDictionary = aContract.out.oclAsType(DataDictionary)]		[comment OPEN assigns the variable to be of type DataDictionary/]
if invariants.checkInv_FixValue_FixValue(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
										dataDictionary_out=[dd_out.dataDictionary.name/],
										fixValueInput=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], fixValueOutput=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fvt.value/]'[else]value=[fvt.value/][/if],
										belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										dataTypeInput=[if (fv.dataType=DataType::String)]DataType(0)[elseif (fv.dataType=DataType::Time)]DataType(1)[elseif (fv.dataType=DataType::Integer)]DataType(2)[elseif (fv.dataType=DataType::DateTime)]DataType(3)[elseif (fv.dataType=DataType::Boolean)]DataType(4)[elseif (fv.dataType=DataType::Double)]DataType(5)[elseif (fv.dataType=DataType::Float)]DataType(6)[else]None[/if]),
										dataTypeOutput=[if (fv.dataType=DataType::String)]DataType(0)[elseif (fv.dataType=DataType::Time)]DataType(1)[elseif (fv.dataType=DataType::Integer)]DataType(2)[elseif (fv.dataType=DataType::DateTime)]DataType(3)[elseif (fv.dataType=DataType::Boolean)]DataType(4)[elseif (fv.dataType=DataType::Double)]DataType(5)[elseif (fv.dataType=DataType::Float)]DataType(6)[else]None[/if]),
										axis_param=0, field=none)
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
[/let]																		[comment CLOSE assigns the variable to be of type DataDictionary/]
[elseif (aContract.out.oclIsTypeOf(DataField))]								[comment OPEN checks that the variable is of type DataField/]
[let df_out : DataField = aContract.out.oclAsType(DataField)]				[comment OPEN assigns the variable to be of type DataField/]
if invariants.checkInv_FixValue_FixValue(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
										dataDictionary_out=[df_out.dataField.eContainer(Workflow::DataDictionary).name/],
										[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fv.value/]'[else]value=[fv.value/][/if], fixValueOutput=[if (fv.dataType=DataType::String or fv.dataType=DataType::Time or fv.dataType=DataType::DateTime)]value='[fvt.value/]'[else]value=[fvt.value/][/if],
										belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										dataTypeInput=[if (fv.dataType=DataType::String)]DataType(0)[elseif (fv.dataType=DataType::Time)]DataType(1)[elseif (fv.dataType=DataType::Integer)]DataType(2)[elseif (fv.dataType=DataType::DateTime)]DataType(3)[elseif (fv.dataType=DataType::Boolean)]DataType(4)[elseif (fv.dataType=DataType::Double)]DataType(5)[elseif (fv.dataType=DataType::Float)]DataType(6)[else]None[/if]),
										dataTypeOutput=[if (fv.dataType=DataType::String)]DataType(0)[elseif (fv.dataType=DataType::Time)]DataType(1)[elseif (fv.dataType=DataType::Integer)]DataType(2)[elseif (fv.dataType=DataType::DateTime)]DataType(3)[elseif (fv.dataType=DataType::Boolean)]DataType(4)[elseif (fv.dataType=DataType::Double)]DataType(5)[elseif (fv.dataType=DataType::Float)]DataType(6)[else]None[/if]),
										axis_param=0, field='[df.dataField.displayName/]')
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
[/let]																		[comment CLOSE assigns the variable to be of type DataField/]
[/if]																		[comment CLOSE checks that the variable is of type DataDictionary or DataField/]
		[/let]																[comment CLOSE assigns the variable to be of type FixValue/]
	[/if]																	[comment CLOSE checks that the variable is of type FixValue/]
	[/let]																	[comment CLOSE assigns the variable to be of type FixValue/]
[elseif (v.oclIsTypeOf(SpecialValue))]										[comment OPEN checks that the type of the value is SpecialValue/]
[let sv : SpecialValue = v.oclAsType(SpecialValue)]							[comment OPEN assigns the variable to be of type SpecialValue/]
[comment]The code below generates the call to invariants of type SpecialValue-FixValue[/comment]
	[if (th.valueResult.oclIsTypeOf(FixValue))]									[comment OPEN checks that the type of the result is FixValue/]
		[let fixVal : FixValue = th.valueResult.oclAsType(FixValue)]			[comment OPEN assigns the variable to be of type FixValue/]
[if (sv.specialType=SpecialType::MISSING and aContract._in.oclIsTypeOf(DataField))]										[comment OPEN checks that SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][let dfa : DataField = aContract._in.oclAsType(DataField)][for (mv : ValueField | dfa.dataField.missingValues) separator(', ')][mv.value/][/for][/let][']'/]
[elseif (sv.specialType=SpecialType::INVALID and aContract._in.oclIsTypeOf(DataField))]
invalid_values_[aContract.name/]=['['/][let dfa : DataField = aContract._in.oclAsType(DataField)][for (mv : ValueField | dfa.dataField.invalidValues) separator(', ')][mv.value/][/for][/let][']'/]
[/if]																			[comment OPEN checks that SpecialType is MISSING or INVALID/]
[if (sv.specialType=SpecialType::MISSING and aContract._in.oclIsTypeOf(DataDictionary))]										[comment OPEN checks that SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][let dd_in : DataDictionary = aContract._in.oclAsType(DataDictionary)][for (dfa : DataField | dd_in.dataDictionary.datafield) separator(', ')][for (mv : ValueField | dfa.dataField.missingValues) separator(', ')][mv.value/][/for][']'/][/for][/let]
[elseif (sv.specialType=SpecialType::INVALID and aContract._in.oclIsTypeOf(DataDictionary))]
invalid_[aContract.name/]=['['/][let dd_in : DataDictionary = aContract._in.oclAsType(DataDictionary)][for (dfa : DataField | dd_in.dataDictionary.datafield) separator(', ')][for (mv : ValueField | dfa.dataField.invalidValues) separator(', ')][mv.value/][/for][']'/][/for][/let]
[/if]																			[comment OPEN checks that SpecialType is MISSING or INVALID/]
			[if (aContract.out.oclIsTypeOf(DataDictionary))]					[comment OPEN checks that the output is a DataDictionary/]
				[let dd_out : DataDictionary = aContract.out.oclAsType(DataDictionary)]		[comment OPEN assigns the variable to be of type DataDictionary/]
if invariants.checkInv_SpecialValue_FixValue(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
							dataDictionary_out=[dd_out.dataDictionary.name/],
							specialTypeInput=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							fixValueOutput=[fixVal.value/],
							belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							dataTypeOutput=[if (fixVal.dataType=DataType::String)]DataType(0)[elseif (fixVal.dataType=DataType::Time)]DataType(1)[elseif (fixVal.dataType=DataType::Integer)]DataType(2)[elseif (fixVal.dataType=DataType::DateTime)]DataType(3)[elseif (fixVal.dataType=DataType::Boolean)]DataType(4)[elseif (fixVal.dataType=DataType::Double)]DataType(5)[elseif (fixVal.dataType=DataType::Float)]DataType(6)[else]None[/if]),
							missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[aContract.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[aContract.name/][else]None[/if], 
							axis_param=0, field=None)
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
				[/let]																		[comment CLOSE assigns the variable to be of type DataDictionary/]
			[elseif(aContract.out.oclIsTypeOf(DataField))]							[comment OPEN checks that the output is a DataField/]
				[let df_out : DataField = aContract.out.oclAsType(DataField)]				[comment OPEN assigns the variable to be of type DataField/]
if invariants.checkInv_SpecialValue_FixValue(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
							dataDictionary_out=[df_out.dataField.eContainer(Workflow::DataDictionary).name/],
							specialTypeInput=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							fixValueOutput=[fixVal.value/],
							belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							dataTypeOutput=[if (fixVal.dataType=DataType::String)]DataType(0)[elseif (fixVal.dataType=DataType::Time)]DataType(1)[elseif (fixVal.dataType=DataType::Integer)]DataType(2)[elseif (fixVal.dataType=DataType::DateTime)]DataType(3)[elseif (fixVal.dataType=DataType::Boolean)]DataType(4)[elseif (fixVal.dataType=DataType::Double)]DataType(5)[elseif (fixVal.dataType=DataType::Float)]DataType(6)[else]None[/if]),
							missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[aContract.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[aContract.name/][else]None[/if], 
							axis_param=0, field='[df.dataField.displayName/]')
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
				[/let]																		[comment CLOSE assigns the variable to be of type DataField/]
			[/if]																[comment CLOSE checks that the output is a DataDictionary or a DataField/]
		[/let]																	[comment CLOSE assigns the variable to be of type FixValue/]
	[/if]																		[comment CLOSE checks that the type of the result is FixValue/]
[comment]The code below generates the call to invariants of type SpecialValue-DerivedValue[/comment]
	[if (th.valueResult.oclIsTypeOf(DerivedValue))]								[comment OPEN checks that the type of the result is DerivedValue/]
		[let derVal : DerivedValue = th.valueResult.oclAsType(DerivedValue)]	[comment OPEN assigns the variable to be of type DerivedValue/]
[if (sv.specialType=SpecialType::MISSING and aContract._in.oclIsTypeOf(DataField))]										[comment OPEN checks that SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][let dfa : DataField = aContract._in.oclAsType(DataField)][for (mv : ValueField | dfa.dataField.missingValues) separator(', ')][mv.value/][/for][/let][']'/]
[elseif (sv.specialType=SpecialType::INVALID and aContract._in.oclIsTypeOf(DataField))]
invalid_values_[aContract.name/]=['['/][let dfa : DataField = aContract._in.oclAsType(DataField)][for (mv : ValueField | dfa.dataField.invalidValues) separator(', ')][mv.value/][/for][/let][']'/]
[/if]																			[comment OPEN checks that SpecialType is MISSING or INVALID/]
[if (sv.specialType=SpecialType::MISSING and aContract._in.oclIsTypeOf(DataDictionary))]										[comment OPEN checks that SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][let dd_in : DataDictionary = aContract._in.oclAsType(DataDictionary)][for (dfa : DataField | dd_in.dataDictionary.datafield) separator(', ')][for (mv : ValueField | dfa.dataField.missingValues) separator(', ')][mv.value/][/for][']'/][/for][/let]
[elseif (sv.specialType=SpecialType::INVALID and aContract._in.oclIsTypeOf(DataDictionary))]
invalid_[aContract.name/]=['['/][let dd_in : DataDictionary = aContract._in.oclAsType(DataDictionary)][for (dfa : DataField | dd_in.dataDictionary.datafield) separator(', ')][for (mv : ValueField | dfa.dataField.invalidValues) separator(', ')][mv.value/][/for][']'/][/for][/let]
[/if]																			[comment OPEN checks that SpecialType is MISSING or INVALID/]
			[if (aContract.out.oclIsTypeOf(DataDictionary))]					[comment OPEN checks that the output is a DataDictionary/]
				[let dd_out : DataDictionary = aContract.out.oclAsType(DataDictionary)]		[comment OPEN assigns the variable to be of type DataDictionary/]
if invariants.checkInv_SpecialValue_DerivedValue(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
							dataDictionary_out=[dd_out.dataDictionary.name/],
							belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							specialTypeInput=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							derivedTypeOutput=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
							missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[aContract.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[aContract.name/][else]None[/if], axis_param=0, field=None)
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
				[/let]																		[comment CLOSE assigns the variable to be of type DataDictionary/]
			[elseif (aContract.out.oclIsTypeOf(DataField))]						[comment OPEN checks that the output is a DataField/]
				[let df_out : DataField = aContract.out.oclAsType(DataField)]				[comment OPEN assigns the variable to be of type DataField/]
if invariants.checkInv_SpecialValue_DerivedValue(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
							dataDictionary_out=[df_out.dataField.eContainer(Workflow::DataDictionary).name/],
							belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
							specialTypeInput=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
							derivedTypeOutput=DerivedType([if (derVal.type=DerivedType::MostFrequent)]0[elseif (derVal.type=DerivedType::Previous)]1[elseif (derVal.type=DerivedType::Next)]2[/if]),
							missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[aContract.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[aContract.name/][else]None[/if], axis_param=0, field='[df.dataField.displayName/]')
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
				[/let]																		[comment CLOSE assigns the variable to be of type DataField/]
			[/if]																[comment CLOSE checks that the output is a DataField/]
		[/let]																	[comment CLOSE assigns the variable to be of type DerivedValue/]
	[/if]																		[comment CLOSE checks that the type of the result is DerivedValue/]
[comment]The code below generates the call to invariants of type SpecialValue-NumOp[/comment]
	[if (th.valueResult.oclIsTypeOf(NumOp))]								[comment OPEN checks that the type of the result is NumOp/]
		[let nop : NumOp = th.valueResult.oclAsType(NumOp)]					[comment OPEN assigns the variable to be of type NumOp/]
[if (sv.specialType=SpecialType::MISSING and aContract._in.oclIsTypeOf(DataField))]										[comment OPEN checks that SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][let dfa : DataField = aContract._in.oclAsType(DataField)][for (mv : ValueField | dfa.dataField.missingValues) separator(', ')][mv.value/][/for][/let][']'/]
[elseif (sv.specialType=SpecialType::INVALID and aContract._in.oclIsTypeOf(DataField))]
invalid_values_[aContract.name/]=['['/][let dfa : DataField = aContract._in.oclAsType(DataField)][for (mv : ValueField | dfa.dataField.invalidValues) separator(', ')][mv.value/][/for][/let][']'/]
[/if]																			[comment OPEN checks that SpecialType is MISSING or INVALID/]
[if (sv.specialType=SpecialType::MISSING and aContract._in.oclIsTypeOf(DataDictionary))]										[comment OPEN checks that SpecialType is MISSING/]
missing_values_[aContract.name/]=['['/][let dd_in : DataDictionary = aContract._in.oclAsType(DataDictionary)][for (dfa : DataField | dd_in.dataDictionary.datafield) separator(', ')][for (mv : ValueField | dfa.dataField.missingValues) separator(', ')][mv.value/][/for][']'/][/for][/let]
[elseif (sv.specialType=SpecialType::INVALID and aContract._in.oclIsTypeOf(DataDictionary))]
invalid_[aContract.name/]=['['/][let dd_in : DataDictionary = aContract._in.oclAsType(DataDictionary)][for (dfa : DataField | dd_in.dataDictionary.datafield) separator(', ')][for (mv : ValueField | dfa.dataField.invalidValues) separator(', ')][mv.value/][/for][']'/][/for][/let]
[/if]																		[comment OPEN checks that SpecialType is MISSING or INVALID/]
			[if (aContract.out.oclIsTypeOf(DataDictionary))]				[comment OPEN checks that the output is a DataDictionary/]
				[let dd_out : DataDictionary = aContract.out.oclAsType(DataDictionary)]		[comment OPEN assigns the variable to be of type DataDictionary/]
if invariants.checkInv_SpecialValue_NumOp(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
										dataDictionary_out=[dd_out.dataDictionary.name/],
										belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										specialTypeInput=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
										numOpOutput=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[aContract.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[aContract.name/][else]None[/if], axis_param=0, field=None)
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
				[/let]														[comment CLOSE assigns the variable to be of type DataDictionary/]
			[elseif (aContract.out.oclIsTypeOf(DataField))]					[comment OPEN checks that the output is a DataField/]
				[let df_out : DataField = aContract.out.oclAsType(DataField)]				[comment OPEN assigns the variable to be of type DataField/]
if invariants.checkInv_SpecialValue_NumOp(dataDictionary_in=[df.dataField.eContainer(Workflow::DataDictionary).name/],
										dataDictionary_out=[df_out.dataField.eContainer(Workflow::DataDictionary).name/],
										belongOp_in=Belong([if (if_cond.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										belongOp_out=Belong([if (th.belongOp=BelongOp::BELONG)]0[else]1[/if]),
										specialTypeInput=SpecialType([if (sv.specialType=SpecialType::MISSING)]0[elseif (sv.specialType=SpecialType::INVALID)]1[elseif (sv.specialType=SpecialType::OUTLIER)]2[/if]),
										numOpOutput=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
										missing_values=[if (sv.specialType=SpecialType::MISSING)]missing_values_[aContract.name/][elseif (sv.specialType=SpecialType::INVALID)]invalid_values_[aContract.name/][else]None[/if], axis_param=0, field='[df.dataField.displayName/]')
	print('[aContract.type/] [aContract.name/] VALIDATED')
else:
	print('[aContract.type/] [aContract.name/] NOT VALIDATED')
				[/let]														[comment CLOSE assigns the variable to be of type DataField/]
			[/if]															[comment CLOSE checks that the output is a DataDictionary or a DataField/]
		[/let]																[comment CLOSE assigns the variable to be of type NumOp/]
	[/if]																	[comment CLOSE checks that the type of the result is NumOp/]
[/let]																		[comment CLOSE assigns the variable to be of type SpecialValue/]
[/if]																		[comment CLOSE checks that the type of the value is FixValue or SpecialValue (if at the beginning)/]
[/for]																		[comment CLOSE traverse all the values associated to the contract/]
[/let]																		[comment CLOSE assigns the variable to be of type Then/]
[/let]																		[comment CLOSE assigns the variable to be of type DataField/]
[/if]																		[comment CLOSE checks that the input is a DataField/]
[/for]																		[comment CLOSE traverse all the If class in the contract/]
[/let]																		[comment CLOSE  assigns the contract to be of type Condition (Invariants)/]
[/template]
























































































































[template public generateDebugContract(aContract : Contract)]

[if (aContract._in.oclIsTypeOf(DataDictionary))]
[let dd : DataDictionary = aContract._in.oclAsType(DataDictionary)]
print('[dd.dataDictionary.name/]')		#DataDictionary _in
print('[dd.dataDictionaryDef.name/]')		#DataDictionaryDef _in
[/let]
[elseif (aContract._in.oclIsTypeOf(DataField))]
[let df : DataField = aContract._in.oclAsType(DataField)]
print('[df.name/]')		#dataField name _in
print('[df.dataField.name/]')		#dataField _in
print('[df.dataFieldDef.name/]')		#dataFieldDef _in
[/let]
[/if]
[if (aContract.out <> null)]
	[if (aContract.out.oclIsTypeOf(DataDictionary))]
[let dd : DataDictionary = aContract.out.oclAsType(DataDictionary)]
print('[dd.dataDictionary.name/]')		#DataDictionary out
print('[dd.dataDictionaryDef.name/]')		#DataDictionaryDef out
[/let]
	[elseif (aContract.out.oclIsTypeOf(DataField))]
[let df : DataField = aContract.out.oclAsType(DataField)]
print('[df.name/]')		#dataField name out
print('[df.dataField.name/]')		#dataField out
print('[df.dataFieldDef.name/]')		#dataFieldDef out
[/let]
	[/if]
[/if]


[if (aContract.oclIsTypeOf(Condition))]
[let cond : Condition = aContract.oclAsType(Condition)]
print('[cond.conditionDef.name/]')			#Condition
[/let]
[elseif (aContract.oclIsTypeOf(FieldRange))]
[let fr : FieldRange = aContract.oclAsType(FieldRange)]
print('[fr.belongOp/]')			#FieldRange
print('[fr.type/]')				#Type in Contract
print('[fr.name/]')		#Name in Contract
print('[fr.fieldRangeDef.name/]')		#FieldRangeDef name
[for (f : Field | fr.field)]
print('[f.dataField.name/]')		#Field in Field/FieldRange
[/for]
[/let]
[elseif (aContract.oclIsTypeOf(ValueRange))]
[let vr : ValueRange = aContract.oclAsType(ValueRange)]
print('[vr.belongOp/]')			#ValueRange
print('[vr.type/]')		#Type in Contract
print('[vr.name/]')		#Name in Contract
print('[vr.valueRangeDef.name/]')	#ValueRangeDef name
[for (v : Value | vr.value)]
[if (v.oclIsTypeOf(FixValue))]
	[let fv : FixValue = v.oclAsType(FixValue)]
	print('[fv.value/]')	#FixValue value
	print('[fv.dataType/]')	#FixValue DataType
	print('[fv.valueFieldDef.name/]')	#FixValue valueFieldDef name
	[/let]
[elseif (v.oclIsTypeOf(Interval))]
	[let inter : Interval = v.oclAsType(Interval)]
	print('[inter.leftMargin/]')	#Interval leftMargin
	print('[inter.rightMargin/]')	#Interval rightMargin
	print('[inter.closureType/]')	#Interval ClosureType
	print('[inter.intervalDef.name/]')	#Interval intervalDef name
	[/let]
[elseif (v.oclIsTypeOf(DerivedValue))]
	[let inter : DerivedValue = v.oclAsType(DerivedValue)]
	print('[inter.type/]')		#DerivedValue type
	print('[inter.derivedValueDef.name/]')	#DerivedValue derivedValueDef name
	[/let]
[elseif (v.oclIsTypeOf(NumOp))]
	[let nop : NumOp = v.oclAsType(NumOp)]
	print('[nop.operation/]')		#NumOp operation
	print('[nop.numOpDef.name/]')	#NumOp numOpDef name
	[/let]
[elseif (v.oclIsTypeOf(SpecialValue))]
	[let sv : SpecialValue = v.oclAsType(SpecialValue)]
	print('[sv.specialType/]')		#SpecialValue specialType
	print('[sv.specialValueDef.name/]')	#SpecialValue specialValueDef name
	[/let]
[/if]
[if (v.quantity <> null)]
	print('[v.quantity.operator/]')
	[if(v.quantity.oclIsTypeOf(AbsoluteValue))]
		[let av : AbsoluteValue = v.quantity.oclAsType(AbsoluteValue)]
		print('[av.value/]')	#AbsoluteValue value
		print('[av.absoluteValueDef.name/]')	#AbsoluteValueDef name
		[/let]
	[elseif (v.quantity.oclIsTypeOf(Percent))]
		[let per : Percent = v.quantity.oclAsType(Percent)]
		print('[per.percent/]')		#Percent percent
		print('[per.percentDef.name/]')		#PercentDef name
		[/let]
	[/if]
[/if]
[/for]
[/let]
[elseif (aContract.oclIsTypeOf(Condition))]
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
[let condition : Condition = aContract.oclAsType(Condition)]
print('[condition.conditionDef.name/]')		#Condition conditionDef name
[/let]
[/if]


[/template]


[template public generateCallTransformation(aParameter : Parameter)]
[comment]Fix the ifs[/comment]
[if (aParameter.oclIsTypeOf(FixValue))]
print('Transformation of type SpecialValue-FixValue')
[/if]
[if (aParameter.oclIsTypeOf(DerivedValue))]
print('Transformation of type SpecialValue-DerivedValue')
[/if]
[if (aParameter.oclIsTypeOf(NumOp))]
print('Transformation of type SpecialValue-NumOp')
[/if]
[if (aParameter.oclIsTypeOf(Map))]
print('Transformation of type FixValue-FixValue')
[/if]

[/template]





































