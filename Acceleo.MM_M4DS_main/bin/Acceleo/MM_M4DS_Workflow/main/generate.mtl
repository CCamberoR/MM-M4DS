[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module generate('https://www.example.org/workflow', 'https://www.example.org/contract')]

[import Acceleo::MM_M4DS_contract::main::generate/]


[**
 * The documentation of the template generateElement.
 * @param aWorkflow
 */]

[template public generateWorkflow(aWorkflow : Workflow)]
[comment @main/]
[generateDataProcessing(aWorkflow)/]
[generateDebug(aWorkflow)/]

[/template]



[template public generateDataProcessing(aWorkflow : Workflow)]
[file ('dataProcessing.py', false, 'UTF-8')]
import pandas as pd
import functions.contract_invariants as contract_invariants
import functions.contract_pre_post as contract_pre_post
from helpers.enumerations import Belong, Operator, Operation, SpecialType, DataType
[comment generate the imports and the class/]
class DataProcessing:
	def generateDataProcessing(self):
		pre_post=contract_pre_post.ContractsPrePost()
		invariants=contract_invariants.ContractsInvariants()
	[for (d : DataProcessing | aWorkflow.dataprocessing)]				[comment OPEN traverse all the DataProcessings/]
	[if (d.incoming = null and d.outgoing=null)]						[comment OPEN checks if the DataProcessing is isolated (no links)/]
#-----------------New DataProcessing-----------------
			[for (dc : DataDictionary | d.inputPort)]					[comment OPEN read all the input datasets and store them/]
		[dc.name/]=pd.read_csv('[dc.path/]')
		[dc.name/]_copy=[dc.name/].copy()

			[/for]														[comment CLOSE read all the input datasets and store them/]
		[for (c : Contract | d.contract)]								[comment OPEN traverse all the contracts in the DataProcessing/]
		[if (c.contract.type=ContractType::PRECONDITION)]				[comment OPEN checks if the if the contract is a Precondition/]
		[generateCallContract(c.contract)/]
		[/if]															[comment CLOSE checks if the if the contract is a Precondition/]
		[/for]															[comment CLOSE traverse all the contracts in the DataProcessing/]

		[for (p : Parameter | d.parameter)]								[comment OPEN traverse all the parameters in the dataProcessing to generate the transformations/]
		[generateCallTransformation(p)/]
		[/for]															[comment CLOSE traverse all the parameters in the dataProcessing to generate the transformations/]

		[for (c : Contract | d.contract)]								[comment OPEN traverse all the contracts in the DataProcessing/]
		[if (c.contract.type=ContractType::POSTCONDITION)]				[comment OPEN checks if the if the contract is a Postcondition/]
		[generateCallContract(c.contract)/]
		[/if]															[comment CLOSE checks if the if the contract is a Postcondition/]
		[/for]															[comment CLOSE traverse all the contracts in the DataProcessing/]
		[for (c : Contract | d.contract)]								[comment OPEN traverse all the contracts in the DataProcessing/]
		[if (c.contract.type=ContractType::INVARIANT)]					[comment OPEN checks if the if the contract is a Invariant/]
		[generateCallContract(c.contract)/]
		[/if]															[comment CLOSE checks if the if the contract is a Invariant/]
		[/for]															[comment CLOSE traverse all the contracts in the DataProcessing/]
	[/if]																[comment CLOSE checks if the DataProcessing is isolated (no links)/]
	[/for]																[comment CLOSE traverse all the DataProcessings/]

	[for (d : DataProcessing | aWorkflow.dataprocessing)]				[comment OPEN traverse all the DataProcessings/]
	[if (d.incoming = null and d.outgoing<>null)]						[comment OPEN checks if the DataProcessing is the first (no input link, an output link)/]
[callRecursiveTemplate(d)/]
	[/if]																[comment CLOSE checks if the DataProcessing is the first (no input link, an output link)/]
	[/for]																[comment CLOSE traverse all the DataProcessings/]


dp=DataProcessing()
dp.generateDataProcessing()
[/file]
[/template]


[template public callRecursiveTemplate(d : DataProcessing)]
#-----------------New DataProcessing-----------------
[for (dc : DataDictionary | d.inputPort)]									[comment OPEN read all the input datasets and store them/]
		[dc.name/]=pd.read_csv('[dc.path/]')
		[dc.name/]_copy=[dc.name/].copy()

[/for]																		[comment CLOSE read all the input datasets and store them/]
[for (c : Contract | d.contract)]											[comment OPEN traverse all the contracts in the DataProcessing/]
	[if (c.contract.type=ContractType::PRECONDITION)]						[comment OPEN checks if the if the contract is a Precondition/]
		[generateCallContract(c.contract)/]
	[/if]																	[comment CLOSE checks if the if the contract is a Precondition/]
[/for]																		[comment CLOSE traverse all the contracts in the DataProcessing/]

[for (p : Parameter | d.parameter)]											[comment OPEN traverse all the parameters in the dataProcessing to generate the transformations/]
		[generateCallTransformation(p)/]
[/for]																		[comment CLOSE traverse all the parameters in the dataProcessing to generate the transformations/]

[for (c : Contract | d.contract)]											[comment OPEN traverse all the contracts in the DataProcessing/]
	[if (c.contract.type=ContractType::POSTCONDITION)]						[comment OPEN checks if the if the contract is a Postcondition/]
		[generateCallContract(c.contract)/]
	[/if]																	[comment CLOSE checks if the if the contract is a Postcondition/]
[/for]																		[comment CLOSE traverse all the contracts in the DataProcessing/]
[for (c : Contract | d.contract)]											[comment OPEN traverse all the contracts in the DataProcessing/]
	[if (c.contract.type=ContractType::INVARIANT)]							[comment OPEN checks if the if the contract is a Invariant/]
		[generateCallContract(c.contract)/]
	[/if]																	[comment CLOSE checks if the if the contract is a Invariant/]
[/for]
	[if (d.outgoing<>null)]													[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
[let nextDp : DataProcessing = d.outgoing.target.oclAsType(DataProcessing)] [comment OPEN assigns the next DataProcessing to a variable/]
[callRecursiveTemplate(nextDp)/]			[comment Recursive call to this template to generate all the DataProcessings linked to the first/]
[/let]																		[comment OPEN assigns the next DataProcessing to a variable/]
	[/if]																	[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]

[/template]












[template public generateDebug(aWorkflow : Workflow)]
[file ('Debug.py', false, 'UTF-8')]
#DATA PROCESSING

[for (d : DataProcessing | aWorkflow.dataprocessing)]
print([d.name/])	#ProcessedName
[if (d.incoming.source.name.toString().equalsIgnoreCase('invalid'))]
print('NO SOURCE')         					#SOURCE
[else]
print('[d.incoming.source.name/]')         #SOURCE
[/if]
[if (d.outgoing.target.name.toString().equalsIgnoreCase('invalid'))]
print('NO TARGET')         					#TARGET
[else]
print('[d.outgoing.target.name/]')         #TARGET
[/if]
#-----------------------------------------------------------------------------
[for (c : Contract | d.contract)]
print('[c.name/]')				#Contract en workflow
print('[c.contractDefinition.name/]')			#ContractDefinition name en ContractDefinition
print('[c.contract.name/]')				#Contract name en CONTRACT
print('[c.contract.type/]')				#Contract type en CONTRACT

#QUIZA SE DEBAN PASAR BASTANTES MAS PARAMETROS-------------------------------------------
[generateDebugContract(c.contract)/]
#//////////////////////////////////////////////////////////////////////////
""""""

[/for]
#######

[/for]



#LINKS		

[for (l : Link | aWorkflow.link)]
print('[l.source.name/]')		#SOURCE
print('[l.target.name/]')		#TARGET

[/for]		

[/file]





















[file ('DebugWorkflow.py', false, 'UTF-8')]
[for (d : DataProcessing | aWorkflow.dataprocessing)]
print([d.name/])	#DataProcessing name
[if (d.incoming.source.name.toString().equalsIgnoreCase('invalid'))]
print('NO SOURCE')         					#SOURCE
[else]
print('[d.incoming.source.name/]')         #SOURCE
[/if]
[if (d.outgoing.target.name.toString().equalsIgnoreCase('invalid'))]
print('NO TARGET')         					#TARGET
[else]
print('[d.outgoing.target.name/]')         #TARGET
[/if]
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
[for (dd : DataDictionary | d.inputPort)]
print('[dd.name/]')         #INPUTPORT name
print('[dd.rows/]')         #INPUTPORT rows
print('[dd.path/]')         #INPUTPORT path
print('[dd.dataDictionaryDefinition.name/]')         #INPUTPORT dataDictionaryDef name
	[for (df : DataField | dd.datafield)]
	print('[df.name/]')         #DataField name
	print('[df.id/]')         #DataField id
	print('[df.dataType/]')         #DataField dataType
	print('[df.target/]')         #DataField target
	print('[df.displayName/]')         #DataField displayName((((()))))
	[if (df.oclIsTypeOf(Categorical))]
	[let cat : Categorical = df.oclAsType(Categorical)]
	print('[cat.ordinal/]')		#Categorical
	print('[cat.categoricalDef.name/]')
	[/let]
	[elseif (df.oclIsTypeOf(Continuous))]
	[let cont : Continuous = df.oclAsType(Continuous)]
	print('[cont.continuousDef.name/]')		#Continuous
		[for (i : Interval | cont.interval)]
		print('[i.leftMargin/]')		#Interval
		print('[i.rightMargin/]')
		print('[i.clousure/]')
		[/for]
	[/let]
	[/if]
		[for (val : ValueField | df.validValues)]
		print('[val.value/]')		#ValidValues
		print('[val.count/]')
	#-------------------------____________________________
		[/for]
		[for (inval : ValueField | df.invalidValues)]
		print('[inval.value/]')		#InvalidValues
		print('[inval.count/]')
	#-------------------------____________________________
		[/for]
		[for (miss : ValueField | df.missingValues)]
		print('[miss.value/]')		#MissingValues
		print('[miss.count/]')
	#-------------------------____________________________
		[/for]

	[/for]
#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
[/for]
[for (dd : DataDictionary | d.outputPort)]
print('[dd.name/]')         #OUTPUTPORT name
print('[dd.rows/]')         #OUTPUTPORT rows
print('[dd.path/]')         #OUTPUTPORT path
print('[dd.dataDictionaryDefinition.name/]')         #INPUTPORT dataDictionaryDef name
	[for (df : DataField | dd.datafield)]
	print('[df.name/]')         #DataField name
	print('[df.id/]')         #DataField id
	print('[df.dataType/]')         #DataField dataType
	print('[df.target/]')         #DataField target
	print('[df.displayName/]')         #DataField displayName((((()))))
	[if (df.oclIsTypeOf(Categorical))]
	[let cat : Categorical = df.oclAsType(Categorical)]
	print('[cat.ordinal/]')		#Categorical
	print('[cat.categoricalDef.name/]')
	[/let]
	[elseif (df.oclIsTypeOf(Continuous))]
	[let cont : Continuous = df.oclAsType(Continuous)]
	print('[cont.continuousDef.name/]')		#Continuous
		[for (i : Interval | cont.interval)]
		print('[i.leftMargin/]')		#Interval
		print('[i.rightMargin/]')
		print('[i.clousure/]')
		[/for]
	[/let]
	[/if]
		[for (val : ValueField | df.validValues)]
		print('[val.value/]')		#ValidValues
		print('[val.count/]')
	#-------------------------____________________________
		[/for]
		[for (inval : ValueField | df.invalidValues)]
		print('[inval.value/]')		#InvalidValues
		print('[inval.count/]')
	#-------------------------____________________________
		[/for]
		[for (miss : ValueField | df.missingValues)]
		print('[miss.value/]')		#MissingValues
		print('[miss.count/]')
	#-------------------------____________________________
		[/for]

	[/for]
#""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
[/for]
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
[for (p : Parameter | d.parameter)]
[if (p.oclIsTypeOf(DerivedValue))]
[let derivedValue : DerivedValue = p.oclAsType(DerivedValue)]
	print('[derivedValue.name/]')			#DerivedValue
	print('[derivedValue.imputeValue/]')
	print('[derivedValue.type/]')
	print('[derivedValue.derivedValueDef.name/]')
[/let]
[elseif (p.oclIsTypeOf(NumOp))]
[let numOp : NumOp = p.oclAsType(NumOp)]
	print('[numOp.name/]')			#NumOp
	print('[numOp.imputeValue/]')
	print('[numOp.operation/]')
	print('[numOp.numOpDef.name/]')
[/let]
[elseif (p.oclIsTypeOf(FixValue))]
[let fixValue : FixValue = p.oclAsType(FixValue)]
	print('[fixValue.name/]')			#FixValue
	print('[fixValue.imputeValue/]')
	print('[fixValue.value/]')			#Es unknown porque el valor concreto no se ha definido, se define en la llamada
	print('[fixValue.fixValueDef.name/]')
[/let]
[elseif (p.oclIsTypeOf(Map))]
[let map : Map = p.oclAsType(Map)]
	print('[map.name/]')			#Map
	print('[map.outvalue/]')
	print('[map.mapDefinition.name/]')
[/let]
[elseif (p.oclIsTypeOf(DerivedField))]
[let derivedField : DerivedField = p.oclAsType(DerivedField)]
	print('[derivedField.name/]')			#DerivedField
	print('[derivedField.der_name/]')
	print('[derivedField.der_dataType/]')
	print('[derivedField.derivedFieldDef.name/]')
	print('[derivedField.der_dataField.name/]')
	print('[derivedField.der_dataField.id/]')
	print('[derivedField.der_dataField.dataType/]')
	print('[derivedField.der_dataField.target/]')
	print('[derivedField.der_dataField.displayName/]')						#DISPLAY_NAME
	[if (derivedField.oclIsTypeOf(Categorical))]
	[let cat : Categorical = derivedField.oclAsType(Categorical)]
		print('[cat.ordinal/]')		#Categorical
		print('[cat.categoricalDef.name/]')
	[/let]
	[elseif (derivedField.oclIsTypeOf(Continuous))]
	[let cont : Continuous = derivedField.oclAsType(Continuous)]
		print('[cont.continuousDef.name/]')		#Continuous
		[for (i : Interval | cont.interval)]
			print('[i.leftMargin/]')		#Interval
			print('[i.rightMargin/]')
			print('[i.clousure/]')
		[/for]
	[/let]
	[/if]
	[for (val : ValueField | derivedField.der_dataField.validValues)]
		print('[val.value/]')		#ValidValues
		print('[val.count/]')
#-------------------------____________________________
	[/for]
	[for (inval : ValueField | derivedField.der_dataField.invalidValues)]
		print('[inval.value/]')		#InvalidValues
		print('[inval.count/]')
#-------------------------____________________________
	[/for]
	[for (miss : ValueField | derivedField.der_dataField.missingValues)]
		print('[miss.value/]')		#MissingValues
		print('[miss.count/]')
#-------------------------____________________________
	[/for]
[/let]
[elseif (p.oclIsTypeOf(Primitive))]
[let primitive : Primitive = p.oclAsType(Primitive)]
	print('[primitive.name/]')			#Primitive
	print('[primitive.value/]')
	print('[primitive.primitiveDef.name/]')
[/let]
[elseif (p.oclIsTypeOf(FilterValue))]
[let filterValue : FilterValue = p.oclAsType(FilterValue)]
	print('[filterValue.name/]')			#FilterValue
	print('[filterValue.filterValueDef.name/]')
	[for (p : Primitive | filterValue.primitive)]
		print('[p.name/]')			#Primitive
		print('[p.value/]')
		print('[p.primitiveDef.name/]')
	[/for]
	[for (mv : MatchingValue | filterValue.matchingvalue)]
		print('[mv.name/]')			#MatchingValue
		[if (mv.oclIsTypeOf(MissingValues))]
		[let missingValues : MissingValues = mv.oclAsType(MissingValues)]
		print('[missingValues.missingValuesDef.name/]')			#MissingValues
		[/let]
		[elseif (mv.oclIsTypeOf(Range))]
		[let range : Range = mv.oclAsType(Range)]
		print('[range.min/]')			#Range
		print('[range.max/]')
		print('[range.rangeDef.name/]')
		[/let]
		[/if]
	[/for]
[/let]
[elseif (p.oclIsTypeOf(MissingValues))]
[let missingValues : MissingValues = p.oclAsType(MissingValues)]
	print('[missingValues.name/]')				#MissingValues
	print('[missingValues.missingValuesDef.name/]')
[/let]
[elseif (p.oclIsTypeOf(Range))]
[let range : Range = p.oclAsType(Range)]
	print('[range.name/]')		#Range
	print('[range.min/]')
	print('[range.max/]')
	print('[range.rangeDef.name/]')
[/let]
[elseif (p.oclIsTypeOf(DiscretizeBin))]
[let discretizeBin : DiscretizeBin = p.oclAsType(DiscretizeBin)]
	print('[discretizeBin.name/]')		#DiscretizeBin
	print('[discretizeBin.binValue/]')
	print('[discretizeBin.discretizeBinDef.name/]')
	[for (i : Interval | discretizeBin.interval)]
		print('[i.leftMargin/]')		#Interval
		print('[i.rightMargin/]')
		print('[i.clousure/]')
	[/for]
[/let]
[elseif (p.oclIsTypeOf(Field))]
[let field : Field = p.oclAsType(Field)]
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
	print('[field.name/]')			#Field
	print('[field.operator/]')
	print('[field.fieldDef.name/]')
	[for (df : DataField | field.dataField)]
		print('[df.name/]')		#DataField
		print('[df.id/]')
		print('[df.dataType/]')
		print('[df.target/]')
		print('[df.displayName/]')
		[if (df.oclIsTypeOf(Categorical))]
		[let cat : Categorical = df.oclAsType(Categorical)]
			print('[cat.ordinal/]')			#Categorical
			print('[cat.categoricalDef.name/]')
		[/let]
		[elseif (df.oclIsTypeOf(Continuous))]
		[let cont : Continuous = df.oclAsType(Continuous)]
			print('[cont.continuousDef.name/]')			#Continuous
			[for (i : Interval | cont.interval)]
				print('[i.leftMargin/]')			#Interval
				print('[i.rightMargin/]')
				print('[i.clousure/]')
			[/for]
		[/let]
		[/if]
		[for (val : ValueField | df.validValues)]
		print('[val.value/]')		#ValidValues
		print('[val.count/]')
	#-------------------------____________________________
		[/for]
		[for (inval : ValueField | df.invalidValues)]
			print('[inval.value/]')		#InvalidValues
			print('[inval.count/]')
	#-------------------------____________________________
		[/for]
		[for (miss : ValueField | df.missingValues)]
			print('[miss.value/]')		#MissingValues
			print('[miss.count/]')
	#-------------------------____________________________
		[/for]
			#-----------------------------------
	[/for]
[/let]
[/if]
[/for]
#-----------------------------------------------------------------------------
[for (c : Contract | d.contract)]
print('[c.name/]')
[/for]
############################################################
[/for]








[/file]

[/template]










































